# Опис домашнього завдання
# У конспекті ми розглянули приклад про розбиття суми на монети. Маємо набір монет [50, 25, 10, 5, 2, 1]. 
# Уявіть, що ви розробляєте систему для касового апарату, яка повинна визначити оптимальний спосіб видачі решти покупцеві.

import time  # Імпортуємо модуль для вимірювання часу виконання функцій

# Жадібний алгоритм для знаходження монет
def find_coins_greedy(amount, coins=[50, 25, 10, 5, 2, 1]):
    result = {}  # Ініціалізуємо словник для зберігання кількості монет кожного номіналу
    for coin in coins:  # Перебираємо кожну монету з доступних номіналів, починаючи з найбільшого
        count = amount // coin  # Розраховуємо, скільки монет даного номіналу можна використати
        if count > 0:  # Якщо кількість монет більше 0, додаємо їх до результату
            result[coin] = count  # Додаємо кількість монет певного номіналу до словника
            amount -= count * coin  # Віднімаємо від суми вартість використаних монет
    return result  # Повертаємо словник з номіналами та кількістю монет

# Алгоритм динамічного програмування для знаходження мінімальної кількості монет
def find_min_coins(amount, coins=[50, 25, 10, 5, 2, 1]):
    # Створюємо масив для зберігання мінімальної кількості монет для кожної суми
    min_coins = [float('inf')] * (amount + 1)
    min_coins[0] = 0  # Для суми 0 кількість монет дорівнює 0
    
    # Масив для зберігання номіналів монет, які використовуються для кожної суми
    coin_used = [0] * (amount + 1)

    # Динамічне програмування для знаходження мінімальної кількості монет для кожної суми
    for amt in range(1, amount + 1):  # Перебираємо всі суми від 1 до заданої суми
        for coin in coins:  # Перебираємо кожний номінал монет
            if coin <= amt and min_coins[amt - coin] + 1 < min_coins[amt]:
                # Якщо монета підходить для поточної суми та кількість монет зменшується
                min_coins[amt] = min_coins[amt - coin] + 1
                coin_used[amt] = coin  # Зберігаємо монету, яку було використано

    # Визначаємо, які монети було використано, відстежуючи назад
    result = {}
    while amount > 0:
        coin = coin_used[amount]  # Отримуємо монету, використану для поточної суми
        if coin in result:
            result[coin] += 1  # Збільшуємо кількість відповідної монети
        else:
            result[coin] = 1  # Додаємо новий номінал монети до результату
        amount -= coin  # Зменшуємо суму на номінал використаної монети
    
    return result  # Повертаємо словник з номіналами та кількістю монет

# Функція для порівняння жадібного алгоритму та алгоритму динамічного програмування
def compare_algorithms(amount):
    # Вимірюємо час виконання жадібного алгоритму
    start_time = time.time()
    greedy_result = find_coins_greedy(amount)
    greedy_time = time.time() - start_time

    # Вимірюємо час виконання алгоритму динамічного програмування
    start_time = time.time()
    dp_result = find_min_coins(amount)
    dp_time = time.time() - start_time

    # Виводимо результати на екран
    print(f"Amount: {amount}")
    print("\nGreedy Algorithm:")
    print(f"Coins: {greedy_result}")
    print(f"Execution Time: {greedy_time:.6f} seconds")

    print("\nDynamic Programming Algorithm:")
    print(f"Coins: {dp_result}")
    print(f"Execution Time: {dp_time:.6f} seconds")

# Основна частина програми
if __name__ == "__main__":
    amount = 113  # Суму можна змінити для тестування з іншими значеннями
    compare_algorithms(amount)  # Викликаємо функцію для порівняння алгоритмів
